// ***** BEGIN GPL LICENSE BLOCK *****
//
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software Foundation,
// Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
//
// ***** END GPL LICENCE BLOCK *****

//    CutAwayShader.osl
//    An OSL shader for Blender. (also see CutAwayShader.py, a Blender custom node that sets up a lot of the parameters for this OSL node.)
//
//    Description:
//    This shader allows cut away cross sections of models to be created.
//    It can also be used for architectural reveals, scientific visualisation and special effects.
//    
//    Insert the shader between the last 'output' of your existing material shader node and the Materials output node.
//    Any point on the material in front of the cut-away plane (and within the bounds of the cut away plane) will be made transparent (or semi transparent if desired)
//
//    "name": "Cutaway Shader",
//    "author": "Dylan Whiteman",
//    "version": (1, 2),
//    "blender": (2, 77, 0),
//    "location": "Shader Node > Add > Effect Shaders > Cutaway Shader",
//    "description": "Cut away the parts of an object (or selected objects) that are in front of the 'Cutaway Plane'",
//    "warning": "Alpha Release (save your work before using!)",
//    "wiki_url": "",
//    "category": "Node"}

#define MIN_BLENDER_VERSION_NO 2.7
#define CAS_ELLIPTICAL_CUTAWAY_SHAPE_TYPE 0
#define CAS_RECTANGULAR_CUTAWAY_SHAPE_TYPE 1
#define CAS_IMAGE_CUTAWAY_SHAPE_TYPE 2

int pointInFrontOfPlane(point thePoint, normal thePlaneNormal, point aPointOnThePlane)
{
    if (dot(thePlaneNormal,thePoint-aPointOnThePlane) > 0)
        return 1;
    else
        return 0;
}
  

// Helper Function: Cast Ray
float rayTrace2(vector startPoint, vector traceDirection, float maxDist, output vector hitPoint, output float hitObjRandNo, float bVersion)
{
    float dist = 0;
    float horn = 0;

    int rayhit = trace (startPoint, traceDirection, "maxdist" , maxDist);
    if (rayhit) 
    {
        getmessage ("trace", "hitdist", dist );
        hitPoint = startPoint + dist * traceDirection;
        
        if (bVersion > 2.6) getmessage ("trace", "object:random", horn);
        hitObjRandNo = horn;
    }
    return dist;
}

 
// helper function
int localPointInPlaneBounds(normal axisx, normal axisy, vector plane_interceptpoint_l, float xwidth, float ywidth)
{
    // decompose the rim_interceptpoint_l segment vector (in world co-ordinates) into  x and y axis compoents, where 
    // x and y are in the planes local co-ordinate system
    float x = dot(plane_interceptpoint_l, axisx); //normalize(axisx)); axisx
    float y = dot(plane_interceptpoint_l, axisy); //normalize(axisy)); axisy
    
   
    // if either the x or y component of rim_interceptpoint_l (which runs from the center of the plane) exceed either boundary,
    // Then the planeline is too long, and is outside the rectangle.
    if ((abs(x) <= (xwidth+0.001)) && (abs(y) <= (ywidth+0.001)))
    {
        // point is inside of rect
        return 1;   
    }
    // point is not inside of rect
    return 0;       
}

float lineInElipseBounds(normal axisx, normal axisy, vector plane_interceptpoint_l, float xwidth, float ywidth, float edgeFadeDist, float edgeFadeSharpness)
{
    float xx = dot(plane_interceptpoint_l,normalize(axisx));
    float yy = dot(plane_interceptpoint_l,normalize(axisy));
    
    //float xscale2 = xwidth*xwidth;
    //float yscale2 = ywidth*ywidth;
    
    
    float x_dist2 = xx * xx / xwidth / xwidth;
    float y_dist2 = yy * yy / ywidth / ywidth;
    
    if (x_dist2 + y_dist2 < 1)
    {
        // point is inside of ellipse/circle
        return 1;   
    }
    
    float edgeFadeDistSacled = edgeFadeDist*sqrt(xwidth*ywidth)*2;
    
    if ( x_dist2 + y_dist2 < edgeFadeDistSacled)
    {
        // the point is outside the ellipse/cirlce
        // If the point is within the fade distance, then return the transparency factor based on the distance to the edge (further away => more transparent)
       return (  1 - pow(((x_dist2 + y_dist2) - 1) / (edgeFadeDistSacled - 1),edgeFadeSharpness));
    }
    
    return 0;
}

/*
    Point in Triangle
    http://www.blackpawn.com/texts/pointinpoly/
*/
int pointInTriangle(point A, point B, point C, point p)
{
    // Compute vectors        
    vector v0 = C - A;
    vector v1 = B - A;
    vector v2 = p - A;

    // Compute dot products
    float dot00 = dot(v0, v0);
    float dot01 = dot(v0, v1);
    float dot02 = dot(v0, v2);
    float dot11 = dot(v1, v1);
    float dot12 = dot(v1, v2);

    // Compute barycentric coordinates
    float invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
    float u = (dot11 * dot02 - dot01 * dot12) * invDenom;
    float v = (dot00 * dot12 - dot01 * dot02) * invDenom;

    // Check if point is in triangle
    if ((u >= 0.00) && (v >= 0.00) && (u + v <= 1.01))
        return 1;
    else
        return 0;
}


//
//point thePoint            The point being tested
//normal traceDirA          First ray tracing direction from thePoint.If the side walls of the object being shaded are hit then 1 is returned
//normal traceDirB/         Second ray tracing direction from thePoint.If the side walls of the object being shaded are hit then 1 is returned
//point cutAwayPlaneOrig,   The ray tracing is only performed if thePoint is in front of the cutaway plane (not necessary otherwise)
//float rimThickness        If the hit distance is greater than the rim width -- then we're not in the rim boundary (this is only true if traceDirA or and traceDirB are perpendicular to the inner/outer walls)   
//float searchDistance      How far to test for a ray trace hit
//float shaderObjsRandomNum The id number that represents the object being shaded. Only mesh hits on this object are valid.
//float bVersion            Ray trace was not supported (in bug free form) before Blender version  2. xx /// get rid of this test later.
int pointInRim5(point thePoint, normal traceDirA, normal traceDirB, point cutAwayPlaneOrig, float rimThickness, float searchDistance, float shaderObjsRandomNum, float bVersion)
{
    int pointIsInRim = 0;

    if (pointInFrontOfPlane(thePoint, traceDirA,cutAwayPlaneOrig))
    {
        // the intercept point is in front (not behind) the cut away plane
        vector hitPointA1;      // set by raytrace
        vector hitPointA2;      // set by raytrace
        vector hitPointB1;      // set by raytrace
        vector hitPointB2;      // set by raytrace
        float meshIDA1;         // set by raytrace
        float meshIDA2;         // set by raytrace
        float meshIDB1;         // set by raytrace
        float meshIDB2;         // set by raytrace
        
        // xxx todo: get rid of bVersion
        // inner hit distance   // inputs ...........................| outputs ............. | input
        float ihdB1 = rayTrace2(thePoint, -traceDirB, searchDistance,  hitPointB1, meshIDB1, bVersion);
        if (meshIDB1 == shaderObjsRandomNum)
        {   
            //                      inputs .............................| outputs .............| input
            float ihdB2 = rayTrace2(thePoint, traceDirB, searchDistance,  hitPointB2, meshIDB2, bVersion);
            float distB = ihdB1+ihdB2;
            
            if ((ihdB1 > 0) && (ihdB2 > 0) && (distB> 0) &&
                (distB <= rimThickness) && 
                (meshIDB2 == shaderObjsRandomNum)) 
            {   
                    pointIsInRim = 1;
            }
        }
        
        if (pointIsInRim == 0)
        {   
            //                      inputs ..............................| outputs ......................
            float ihdA1 = rayTrace2(thePoint, -traceDirA, searchDistance,  hitPointA1, meshIDA1, bVersion);
            if (meshIDA1 == shaderObjsRandomNum)
            {
                //                      inputs .............................| outputs ......................
                float ihdA2 = rayTrace2(thePoint, traceDirA, searchDistance,  hitPointA2, meshIDA2, bVersion);
                float distA = ihdA1+ihdA2;
                
                if ((ihdA1 > 0) && (ihdA2 > 0) && (distA > 0) &&
                    (distA <= rimThickness) &&  
                    (meshIDA2 == shaderObjsRandomNum))
                {   
                        pointIsInRim = 1;
                }
            }
        }
    }
    return pointIsInRim;
}

// return 0 if u or v is out side the range 0 to 1
// return 1 otherwise.
int uvInbounds(float u, float v)
{
    if (u < 0.01) return 0;
    if (u > 0.99) return 0;

    if (v < 0.01) return 0;
    if (v > 0.99) return 0;
    else return 1;
}


 
// Returns:
//      Returns 1: if the incident ray I passing through shade point P intersects
//      the plane with center planeCenter and normal planeNormal.
//
//      Outputs theInterceptPoint = the point where the ray passes through the plane
//      Outputs plane_interceptpoint_l = the line that runs from the plane center to the intercept point
//
//      Sets N (the normal of the point being shaded) to planeNormal
//
//      Returns 0: otherwise, with theInterceptPoint and plane_interceptpoint_l undefined
// 
int incidentRayInterceptsPlane( normal planeNormal, 
                                point planeCenter, 
                                output vector plane_interceptpoint_l, 
                                output vector plane_interceptpoint_g)
{ 
    // For the triangle  H = a + b,
    // where: H is the hypotenuse, 
    //        a lies along a plane (plane_interceptpoint_l)
    //        b is perpendicular to a plane = planeNormal
    //        cosTheta is the angle from the normal to the plane, b,  and the incident ray, I,  from the camera to 
    //        the shading point.
    //
    // We want to see if this ray I , passing through P, intersects with the rim fill 
    // plane (defined by its normal and center point above) .
    //
    // First calculate cosTheta
    float cosTheta = dot(planeNormal,I);
    
    // Does the ray I passing through P intersect with the rim fill plane with normal planeNormal?
    if (cosTheta > 0)
    {
        // Yes. The ray does intersect with this plane.
         
        // Now check if the intersection point lies in the rim segment's plane boundary.
        // To do this we need to find where the ray I passing through P intesects with the plane

        // H1 is the 'hypotenuse' line from the point P being shaded to the rim plane segments 
        // center point(planeCenter)
        vector H1 = P - planeCenter;
        
        // b is a perpendicular line from the plane to the point P being shaded.
        // len_b is the length of b.
        float len_b = dot(planeNormal,H1);
        
        // H2 is the 'hypotenuse' (in the direction of I) from P to the intercept point that 
        // passes through the plane 
        vector H2 = I * len_b / cosTheta; 
             
        // Output the intercept point of the ray I passing through P and the plane in world co-ordinates.
        plane_interceptpoint_g =  P - H2;

        // Output the intercept point of the ray I passing through P and the plane in local object go-ordinates.
        plane_interceptpoint_l = planeCenter - plane_interceptpoint_g;
        
        // There was an intercept point.
        return 1;
    }
    else
    {
        // there was no intercept point
        return 0;
    }  
}  

// Complex cutaway plane shape defined by boundary edges       
// The complex, user defined, cutaway plane shape is made up of four or more triangles.
// For a given boundary edge segment running between points M and N, the third point O is placed at the
// geometrical center of the plane.
// For a triangle defined by two edge segment boundary vertices v0 and v1 and the planes center origin:
//      - If the point at the end of line vector A lies inside the triangle, then
//        it is inside the complex shaped boundary and we can 'cut away' this shade point.

// Iterate through all the triangles. This could probably performed faster with a 'binary search' method,
//  but for now -- we will just step through all triangles until we get a hit -- or we run out of triangles.
int pointInPolygon(point cutAwayPlaneOrigin, vector planeScale, vector planeNx, vector planeNy, vector planeNz, string polygonXMLData, point tstPt)
{
    // the dictionary of polygon points for this shader
    int dictNodeId = dict_find(polygonXMLData, "//R//E");
    
    vector vag;
    vector vbg;
    
    // Vertex A Global coords (vag) is actually in local coords when read
    dict_value(dictNodeId, "v", vag);           
          
    // calculate Vertex A in global coords      
    vag = planeNx * vag[0] * planeScale[0]  +   
          planeNy * vag[1] * planeScale[1]  + 
          planeNz * vag[2] * planeScale[2]  +
          cutAwayPlaneOrigin;
    dictNodeId =  dict_next(dictNodeId);

    // Iterate over all the outside edges of the plane. See if the point projects inside of the plane boundary.
    do
    {
        // Vertex B Global coords (vbg) is actually in local coords when read
        dict_value(dictNodeId, "v", vbg);
       
        // calculate Vertex B in global coords
        vbg =   planeNx * vbg[0] * planeScale[0]  +     //Vertex A Global coords (vag) is actually local until next startement
                planeNy * vbg[1] * planeScale[1]  + 
                planeNz * vbg[2] * planeScale[2]  +
                cutAwayPlaneOrigin;

        if (pointInTriangle(vag, vbg, cutAwayPlaneOrigin, tstPt))      
        {
            // The point being shaded lies within the complex plane shape boundary, so it will be cut away.
            return 1;
        }
        vag = vbg;
        dictNodeId =  dict_next(dictNodeId);
    }
    while (dictNodeId > 0);
    return 0;
}

// The actual OSL cutaway shader
shader cutAwayView(
    closure color ShaderIn = 0,
    color RimColor = color(1,0,0),
    float EffectMixFactor = 1.0,
    float RimEffectMixFactor = 1.0,
    int InvertCutawayBounds = 0,
    float EdgeFadeDistance = 0.0,
    float EdgeFadeSharpness = 1.0,
    int DrawMode_circular0_rectangular1 = 0,
    vector CutAwayLocation = 0,
    vector Rotation =0.0,
    vector Scale = 0.0,
    vector OriginOffset = 0,
    int InnerMesh0_OuterMesh1 = 1,
    string RimSegmentXMLData = "",
    float RimThickness = 0.0,
    int RimFillEnable = 0,
    int RimOcclusionEnable = 1,
    string cutAwayImg = "//textures/cutawayImg1.png",

    output closure color CutAwayShaderOut = ShaderIn,
    output float CutAwayFac = 0.0,
    output float RimFac = 0.0,
    output vector Normal = N
)
{
    //*****************************************************************************************
    // Cut away calculations follow.
    // The shader calculates if the point P (being shaded) be made transparent (cut away) or left as is (not cut away)
    // If the point P being shaded is on the 'cut away' side of the cutaway plane, AND is within the defined bounds of the plane (or complex plane shape) then make this point P
    // transparent (or partially transparent if the user set EffectMixFactor  < 1
    
    // A temp solotion. Verstion of Blender prior to 2.7 didnot correctly suport trace commands or unique object ID attribute requests.
    float bVersion = 2.7;
    
    // The unique id of the object beeing shaded.
    // This is used to see if the rim should be occluded due to other geometry. 
    // It is also used to see if if a potential rim point liese between the inner and out mesh if this object has been 'solidified'.
    float objectRandNum =0 ;
    if (bVersion > 2.6) getattribute("object:random", objectRandNum);
    
    int cutawayPlaneType = DrawMode_circular0_rectangular1;     // 0 for circular/elliptical, 1 for rectangular, 2 for image based cutaway shape
    int outer = InnerMesh0_OuterMesh1;                          // This is the outer material if outer = 1
    vector rot = degrees(Rotation);                             // The x-y-z rotation of the cutaway plane in world coordinates

    color RimColor2 = RimColor;                                 // The color of the rim - default = red.
    int RimFillEnable2 = RimFillEnable;                         // 0 = no rim, 1 = emission rim, 10 = diffuse rim
    color cutawayImgCol = 0;                                    // only used if the user selects an image to define the cutaway
    float cutawayImgFac = 0;                                    // only used if the user selects an image to define the cutaway
    float rimShadedFac = 0;                                     // Calculated result. 0 if no rim point being shaded, 1 if being fully shaded, from 0 to 1 if partially shaded.
    int useEmissionForRim = 1;
    
    if (RimFillEnable2 > 9)
    {
        RimFillEnable2 = RimFillEnable2 - 9;
        // will use diffuse shader for rim
        useEmissionForRim = 0;
    }
    
    // cutAwayShaderFac = 0 if there is no cut away effect (i.e the mesh will not be cut away)
    //                  = 1 for fully cut away (in between values => transparency mix)
    float cutAwayShaderFac= 0.0;
    
    // plane axes in local obj (non rotated) co-ordinates
    normal nx = normal(1.0, 0.0, 0.0);
    normal ny = normal(0.0, 1.0, 0.0);
    normal nz = normal(0.0, 0.0, 1.0);

    // plane axes in global/world co-ordinates. (the user has probably rotated the cut away plane in the 3D view) 
    nx = rotate(nx,radians(rot[0]),point(0,0,0),point(1,0,0));
    nx = rotate(nx,radians(rot[1]),point(0,0,0),point(0,1,0));
    nx = rotate(nx,radians(rot[2]),point(0,0,0),point(0,0,1));
    
    ny = rotate(ny,radians(rot[0]),point(0,0,0),point(1,0,0));
    ny = rotate(ny,radians(rot[1]),point(0,0,0),point(0,1,0));
    ny = rotate(ny,radians(rot[2]),point(0,0,0),point(0,0,1));
    
    nz = rotate(nz,radians(rot[0]),point(0,0,0),point(1,0,0));
    nz = rotate(nz,radians(rot[1]),point(0,0,0),point(0,1,0));
    nz = rotate(nz,radians(rot[2]),point(0,0,0) ,point(0,0,1));
    
    nx = normalize(nx);
    ny = normalize(ny);
    nz = normalize(nz);
    
    
    // Convert the OriginOffset from local to world co-ordinates.
    // The OriginOffset is the offset from the geometrical center of the plane to the user defined plane 'origin', 
    // which can be any where (e.g. on a plane edge for scaling from edge purposes)
    vector origOffset = nx * OriginOffset[0] * Scale [0] + 
                        ny * OriginOffset[1] * Scale [1] +
                        nz * OriginOffset[2] * Scale [2] ;
    
    // Plane 'center' origin in world co-ords
    vector CutAwayOrigin = CutAwayLocation + origOffset;

    
    // Points are only shaded if they fall within the bounds of the cutaway plane.
    // Only points on the 'green' side of the plane are 'go' for being cut-away
    // For the Triangle with vectors A + B = C  
    // where:   C is the hypotenuse vector from the plane origin (CutAwayOrigin) to the shade point P 'above' the cutaway plane
    //          A is a vector parallel to and ruining along the surface of the cutaway plane, 
    //          B a vector perpendicular to the plane.
    //          B runs in the same direction as nz, the planes z axis.
    //          
    //    
    //          lenB is the length of B. 
    //          If lenB is > 0 then our shade point P is in front of (on the cut-away side of) the plane

    // Calculate which side of the cut away plane the point being shaded is.        
    vector C = (P-CutAwayOrigin);
    float lenB = dot(nz,C); 
    if (lenB  > 0)
    {
        // We're on the Green side => OK to cut away, BUT only if shade point P  is 'within' the cutaway plane's bounds
        // The cut away plane's x,y bounds are given by the Scale (x,y,z) input. (We ignore z as a plane has no z scale)

        // If a ray from shade point P in the direction of nz intercepts the plane within the planes poligonal boundaries
        // then point P is 'inside' the plane's boundary and should be cutaway.
        
        // A is the vector parallel to the plane. It runs from the plane origin to where C intercepts the plane
        vector A = C - lenB*nz;    
    
        // Old cut away code -- when the plane was just a rectangle shape (as opposed to a polygon)
        // Cut away the surface at point P if A lies within the cutaway plane boundaries
        //if (cutawayPlaneType == 1)       
        //{
            // Rectangular Cutaway plane defined by width and breadth (scale[0], scale[1])
            // cutAwayShaderFac = 1 if the line vector A along the planes surface does not exceed the bounds.
        //    cutAwayShaderFac = localPointInPlaneBounds(nx, ny, A, Scale[0], Scale[1]);    
        //}
        
        
        if (cutawayPlaneType == CAS_RECTANGULAR_CUTAWAY_SHAPE_TYPE)
        {
            // The dictionary of polygon points for this shader - passed as an input string
            // XML format example for a 2D rectangular (square in this example) plane.
            // R = rim definition
            // E = edge
            // v = vertex point on an edge "x,y,z" coords (z should be 0)
            // <R><E v="-1.0000,1.0000,0.0000" /><E v="-1.0000,-1.0000,0.0000" /><E v="1.0000,-1.0000,0.0000" /><E v="1.0000,1.0000,0.0000" /><E v="-1.0000,1.0000,0.0000" /></R>
            int dictNodeId = dict_find(RimSegmentXMLData, "//R//E");
            
            // Vertex A and B in local and global (world) coords.
            vector val;
            vector vbl;
            vector vag;
            vector vbg;
            
            // Edge fadeaway variables
            // used to keep track of the closest point to the outside of the cutaway plane (for fade off calcualtions)
            float tempFadeFactor;
            point P_projectedOntoPlane;
            float edgeDist;
            
            // Vertex A Local coords (val) 
            dict_value(dictNodeId, "v", val);           
                  
            // Vertex A  Global (world) coords (vag)      
            vag = nx * val[0] * Scale[0]  +   
                  ny * val[1] * Scale[1]  + 
                  nz * val[2] * Scale[2]  +
                  CutAwayOrigin;
                  
            dictNodeId =  dict_next(dictNodeId);

            // Iterate over all the outside edges of the plane. See if the point projects inside of the plane boundary.
            do
            {
                // Vertex B Local coords (vbg) is actually in local coords when read
                dict_value(dictNodeId, "v", vbl);
               
                // Vertex B in global (world) coords
                vbg =   nx * vbl[0] * Scale[0]  +    
                        ny * vbl[1] * Scale[1]  + 
                        nz * vbl[2] * Scale[2]  +
                        CutAwayOrigin;

                if (pointInTriangle(vag, vbg, CutAwayOrigin, P))      
                {
                    cutAwayShaderFac = 1;
                    break;
                }
                else
                {
                    // The point does not lie in the triangle formed by the outer edge segment and the origin of the cutaway plane shape
                    // So, see if is close enough to an edge to have a fade factor 
                    // (e.g. if the user has a fade factor of 1m, then points within 1m from the edge will be ratiometrically fadedout.
                    // Only do the calcs if the user has set an edgeFadeDistanceFactor > 0m
                    if (EdgeFadeDistance > 0)
                    {
                        P_projectedOntoPlane = A + CutAwayOrigin;
                        edgeDist = distance (val, vbl, P_projectedOntoPlane);
                        if (edgeDist <= EdgeFadeDistance)
                        {
                            tempFadeFactor = pow(1 - edgeDist/EdgeFadeDistance, EdgeFadeSharpness);
                            
                            // If this is the closest shading point yet to the cutaway plane shape - then remember the fade
                            if (tempFadeFactor > cutAwayShaderFac)
                            {
                                cutAwayShaderFac = tempFadeFactor;
                            }
                        }
                    }
                }
                vag = vbg;
                val = vbl;
                dictNodeId =  dict_next(dictNodeId);
            }
            while (dictNodeId > 0);
        }
        
        else if (cutawayPlaneType == CAS_ELLIPTICAL_CUTAWAY_SHAPE_TYPE) 
        {
            // Elliptical cutaway plane defined by  semimajor and semiminor axes (scale[0], scale[1])
            // cutAwayShaderFac => 1  if the line vector A along the planes surface does not exceed the circle/ellipse bounds.
            cutAwayShaderFac = lineInElipseBounds(nx, ny, A, Scale[0], Scale[1], EdgeFadeDistance, EdgeFadeSharpness); 
        }
        
        else if (cutawayPlaneType == CAS_IMAGE_CUTAWAY_SHAPE_TYPE)
        {
            // The user has chosen an image texture to represent what parts of the material to cutaway
            int useImg = 1;
            float alpha = 1.0;
            
            // Compute UV co-ordinates to use for the cut away image.
            // Project the shade point P onto the cutaway plane along the plane's local z-axis
            point uv = (point(dot(A, nx), dot(A, ny), 0.0)  / point (Scale[0]*2.0, Scale[1]*2.0, 0.0)) + point (0.5, 0.5, 0.0);
            int inbounds = uvInbounds(uv[0], uv[1]);

            if (useImg)  
            {  
                if (inbounds)
                {
                    // we are cutting away (based on the image RGB). 
                    cutAwayShaderFac = 1;
                    
                    // Retrieve the image RGB at the uv point. The luminance will define the opacity.
                    // Dark => don't cut away. White => full cutaway.
                    cutawayImgCol = texture(cutAwayImg, uv[0], 1.0 - uv[1]); //, "interp", "closest"); //, "alpha", alpha);
                    cutawayImgFac = luminance(cutawayImgCol);
                    if (InvertCutawayBounds == 0)
                        cutawayImgFac = luminance(cutawayImgCol);
                    else
                        cutawayImgFac = 1.0 - luminance(cutawayImgCol);
                 }
            }
        }           
    }
    
    // If the user wants to cut away the outside of the plane bounds, then invert the cutaway result (unless the cutawayPlaneType == image based == 2)
    cutAwayShaderFac = abs(cutAwayShaderFac - InvertCutawayBounds*(cutawayPlaneType != 2));
    

    // At this stage of the code we have created the cutaway effect.
    // The next stage is to determin if a rim needs to be shaded where the object has been cutaway.
    
    //*****************************************************************************************
    // Rim code follows:
    // Next calculate if this point P is part of a rim that is formed when a mesh with 'thickness' is cut.
    // The user has the option of having the rim shaded -- or not having it shaded.
    // The solidify modifier can be used to create the inner mesh. A rim is formed between the inner and outer mesh.
    
    // The overall rim shading method works as follows:
    //  Step 1) A rim can only be seen if the surface (that normal hides it) has been cut away.
    //          So test to see if the current shade point P is cut away (cutAwayShaderFac == 1)
    //          Rim drawing is only performed if this is an outer surface (outer == 1)
    //          If P is outer and cutaway, then it *might* be used to shade a part of the rim.
    //
    //  Step 2) Fire a ray from shade point P along the direction of the incidence vector I (the line from the camera to P).
    //          If the ray intercepts the rim, then P can look to the camera as though it actually is a point on the rim.
    //
    //  Step 3) If the ray does intercept a segment of the rim, calculate the intercept point.
    //          Note that for a rectangular cut away plane there are bottom rim, top rim, left rim and right rim segments.
    //          With the cutaway plane as 'the back of a box', the rim segments form the 'sides of the box'
    //
    //          These 'virtual' rim segment planes are defined by: 
    //              - Their origin and the 
    //              - The plane segment's normal.
    //          
    //          Step 3a)
    //          e.g: The origin point of the 'left' rim segment's plane is calculated as follows.
    //                -  The 'left' side of the box is cutaway plane (CAP) width/2 away, along the nx axis,
    //                   from the center of the CAP (the 'box base')
    //                   
    //                   This gives how far 'up' and 'to the side' the 'left' side of the box (the left rim segment plane) is.
    //                   The left rim segment origin's distance 'forward' from the cut away plane is calculated as follows.
    //
    //                   Knowing that the point P beng shaded lies on the exterior surface of the object, then the origin
    //                   of the left rim segment lies half the rim thickness back, where back is defined as in the nz
    //                   direction (the 'perpendicular' line to the CAP -- or box base)
    //
    //                -   The 'left' rim segments normal is defined as nx.
    //
    //                    Also:
    //                    The 'right' rim segment's normal is defined as -nx.
    //                    The 'top' rim segment's normal is defined as -ny.
    //                    The 'bottom' rim segments normal is defines as ny.
    //
    //                So - now we can define a plane origin and normal that represent the sides of a box with the
    //                cutaway plane as its base.
    //
    //  Step 4)       As noted above, when a ray is fired from shade point P along I, we see if it intercepts any of the 
    //                sides of the box (the left, right, top or bottom rim segments) and if so the co-ordinates of the
    //                intercept point.
    //
    //                In Step 4 we see if the intercept point Pr lies in the rim. (it is possible to intercept the walls
    //                of the box, but not be on the rim).
    //
    //                This is done by firing two rays from Pr. On ray 'forwards' and the other 'backwards'
    //                If Pr is a point that is actually on the rim, then the 'forwards' ray should hit the outer surface and 
    //                the 'backwards' ray should hit the inner surface. If the distance between the outer hit point and the 
    //                the inner hit point matches the thickness of the rim, then the Pr point is on the rim and should be
    //                shaded as such.
    //
    //                A complication in firing the 'forwards' and 'backwards' ray from Pr is that a 'true' forwards or
    //                or backwards ray will intersect the inner or outer mesh normal to the surface. It is not possible
    //                ahead of time however to know which angle to fire the forward or backward ray from Pr to meet this
    //                criterion. It is possible to fire out several 'forward' rays and iteratively deduce when the ray from
    //                Pr to the hit point is normal to the surface. Practically however, it is generally possible to
    //                fire out two sets of forward/backward rays. The first forward/backward set at 90 degrees to the second.
    //                After calculating the distance between the inner/outer hit points for each forward/backward set, the shortest
    //                of the two solutions is used to see if the rim width criterion is met.
    //
    //                This method is repeated for the 'left', 'right', 'top', 'bottom' and 'rear' plane segments that
    //                make up the rim.
    //
    //                It is envisioned that arbitrary cut out shapes can be achieved by defining multiple plane segments
    //                that will make up the rim. This work is yet to be performed.
    //
    //  Drawbacks:    It is not possible at the time of writing to know whether the inner and outer surface hit points
    //                (from the forward/reverse rays fired from Pr) actually belong to the mesh we are shading. The hit points
    //                could belong to a completely different mesh. There is a mechanism in OSL to find the name of the 
    //                surface that has been hit -- but does not appear to work correctly in Blender  at this point  
    //                (it crashes). It is also possible to fire a point form Pr and hit the inner surface twice. This
    //                too could be avoided if it was possible to know the name of the surface that had been hit.
    //                
    //                If the cutaway object being shaded is more cubic (as opposed to spherical), then the rim
    //                is not always correctly filled near the corners. Firing an additional 'forward/backward' ray 
    //                (say at 45 degrees to the first two sets) could be used to improve this. Using a bevel modifier can
    //                also 'round' the corners a bit -- or keeping the rim thickness down can help too.
    //                This is an area to continue working on.
    //                

    //float rimShadedFac = 0;                       // if this gets set to 1, then then this point P should be shaded as a rim.
    float searchDist1 = RimThickness;//*1.5;        // the search distances from the rimpoint to the inner or outer mesh wall
    float searchDist2 = RimThickness;//*1.5; 
    
    vector rim_interceptpoint_g = vector(0,0,0);    // Calculated result. The actual rim point  (if there is one). in global co-ordinates 
    vector rim_interceptpoint_l ;                   // Calculated result. The actual rim point  (if there is one). in local cutaway plane co-ordinates 

    int occlude = 0;                                // Set to 1 if the rim is occluded by other geometry
    
    // Only draw a rim plane IF we are shading the outer surface AND
    // the point P is being cut away AND the user has selected rimfill AND this is a rectilinear cutaway shape
    if ((outer == 1) && (cutAwayShaderFac == 1) && (RimFillEnable2 != 0) && (cutawayPlaneType ==1) && 99 == 99)
    {
        // the thickness of the rim
        float thickness = RimThickness;
        
        //vector  pCenterz = (abs(dot(P-CutAwayOrigin,nz)) -  thickness/2 )*nz ;
        
        // Define the vertices that make up the cut-away plane.
        // These will be read in from a dictionary (sent to us by the py_node helper)
        point val;              // val and vbl vertices in local (unscaled, unrotated) object coordinates.
        point vbl;              // These vertices make the cut-away plane (4 verts for rectangular plane)
        
        point vag;              // vag and vblg vertices in global (scaled, rotated, translated) world coordinates.
        point vbg;
        
        point rimseg_center_g;  // the geometric center of a rim segment plane in global co-ords
        normal rimseg_normal_g; // the normal of the rim segment plane in global co-ords
        vector rimseg_edge_g;   // a vector in global co-ords that runs along and in parallel with the rim segment

        float rimseg_xlen_l;    // The 'x-axis' (in local co-ordinates) length of a rims segment plane
        float rimseg_ylen_l;    // The 'y-axis' (in local co-ordinates) length of a rims segment plane
     
        // The cut-away plane verts are read in from the py node helper as an XML string
        // Note: the cutaway plane outline is made up of connected edges. 
        // Each edge has two verts. Read in the verts two at a time
        // Find the first vert in the xml mesh definition.
        int dictNodeId = dict_find(RimSegmentXMLData, "//R//E");

        // get vert val in local co-ords
        dict_value(dictNodeId, "v", val); 
        
        // convert  val to vag (local co-ords to global co-ords (translated, rotated, scaled)    
        vag = nx * val[0] * Scale[0]  +   
              ny * val[1] * Scale[1]  + 
              nz * val[2] * Scale[2]  +
              CutAwayOrigin;
        
        // tee up access to the next vert in the cutaway plane edge      
        dictNodeId =  dict_next(dictNodeId);
        do
        {
            rimShadedFac = 0;
            //RimColor2 = color(1,0,0);
            
            // get vertex b in local co-ords vbl
            dict_value(dictNodeId, "v", vbl);
    
            // convert  vbl to global (world) coords (vbg)
            vbg = nx * vbl[0] * Scale[0]  +   
                  ny * vbl[1] * Scale[1]  + 
                  nz * vbl[2] * Scale[2]  +
                  CutAwayOrigin;
  
            // the rim center lies half way between the two verts that define the edge segment.      
            rimseg_center_g =  mix(vbg, vag, 0.5);   
  
            // The normal of the rim plane is perpendicular to edge direction and the normal of 
            // the cutaway plane. The rim shader (e.g. diffuse) uses this normal so that the edge rim
            // reflects/absorbs light in the same way an actual rim mesh would
            rimseg_normal_g = normalize(cross(vbg - vag, nz));              
                         
            // When shading, the rim segment plane needs to point towards the camera. FLip it if needed.
            // (Note OSL's face_forward(...) seems to crash Blender.
            if (dot(rimseg_normal_g, I) < 0)
            {
                rimseg_normal_g = -rimseg_normal_g;
            }
            
            // calculate the scaled rimseg width and breadth in local co-ords      
            rimseg_edge_g = (val - vbl)*Scale/2;
            rimseg_xlen_l = abs(rimseg_edge_g[0]);
            rimseg_ylen_l = abs(rimseg_edge_g[1]); 
            
            // Test if the shaded point is on the rim AND that the rim is contained within the models edge boundary (e.g. within the side of a cube)
            // In this case the rim edge normal is perpendicular to the cutaway planes normal (i.e  rimseg_normal_g = normalize(cross(vbg - vag, nz)); 
            // incidentRayInterceptsPlane:  Returns 1 if the incident ray intercepts an 'infinite' sized rim plane segment.
            // Output rim_interceptpoint_l: A line that runs along the surface from the rim plane origin 
            //                              to the rim plane intercept point.
            // Output rim_interceptpoint_g: The point where the incident ray intercepts the plane rim.
            //
            //  
            //                              inputs .........................| outputs ......................
            if (incidentRayInterceptsPlane(rimseg_normal_g, rimseg_center_g, rim_interceptpoint_l, rim_interceptpoint_g))
            {
                // incidentRayInterceptsPlane:  Returns 1 if the incident ray intercepts an 'infinite' sized rim plane segment.
                // Output rim_interceptpoint_l: A line that runs along the surface from the rim plane origin 
                //                              to the rim plane intercept point.
                // Output rim_interceptpoint_g: The point where the incident ray intercepts the plane rim. 
                if (localPointInPlaneBounds(nx, ny, rim_interceptpoint_l , rimseg_xlen_l , rimseg_ylen_l))
                {
                    rimShadedFac = pointInRim5(rim_interceptpoint_g, nz,  nx, rimseg_center_g, thickness, searchDist2, objectRandNum, bVersion);
                    if (rimShadedFac != 0)
                    {
                        N = rimseg_normal_g;
                        break;
                    }
                    
                    // If we are here then we haven't shaded the rim point yet
                    rimShadedFac = pointInRim5(rim_interceptpoint_g, nz,  ny, rimseg_center_g, thickness, searchDist2, objectRandNum, bVersion);
                    if (rimShadedFac != 0)
                    {
                         N = rimseg_normal_g;
                         break;
                    }
                }
            }
            
            
            // If we are here then we haven't shaded the rim point yet
            // Test if the shaded point is on the rim AND that the rim is contained on the models edge boundary (e.g. when the cut awau plane is bigger than the model bounds)
            // In this case the rim edge normal is perpendicular to the cutaway planes normal (i.e  rimseg_normal_g = nz);   
            rimseg_normal_g = nz;              
                         
            // When shading, the rim segment plane needs to point towards the camera. FLip it if needed.
            // (Note OSL's face_forward(...) seems to crash Blender.
            if (dot(rimseg_normal_g, I) < 0)
            {
                rimseg_normal_g = -rimseg_normal_g;
            }
            
            //                         inputs .........................| outputs ......................
            if (incidentRayInterceptsPlane(rimseg_normal_g, rimseg_center_g, rim_interceptpoint_l, rim_interceptpoint_g))
            {
                // The incident ray does intercept an infinite rim plane segment.
                // Does the rim_interceptpoint_l vector, that runs from the rim plane segment origin to the intercept point, lie in
                // inside a 'rough' boundary. The boundary is defined by the width and breadth of current edge segment of the cut away plane
                // This rough boundary can extend past the front surface of the mesh being shaded.
                if (localPointInPlaneBounds(nz, nz, rim_interceptpoint_l , rimseg_xlen_l , rimseg_ylen_l))
                {
                    rimShadedFac =    pointInRim5(rim_interceptpoint_g, nx,  ny, rimseg_center_g, thickness, searchDist2, objectRandNum, bVersion);
                    if (rimShadedFac != 0)
                    {
                         // If the 'valid' rimpoint at rim_interceptpoint_g should not be shown (because a rim point can only be shown in cutaway areas) then hide it.
                        int rimPtOkToShade =  pointInPolygon(CutAwayOrigin,  Scale,  nx,  ny,  nz,  RimSegmentXMLData, rim_interceptpoint_g);
                        if (rimPtOkToShade == 0) rimShadedFac = 0;
                      }
                    
                    if (rimShadedFac != 0)
                    {
                        // We have a rim point we want to shade. Not need to keep looping
                        //RimColor2 = color(1,1,0);
                        N = nz;
                        if (dot(N, I) < 0)
                        {
                            N = -N;
                        }
                        break;
                    }
                }
             }
            
            // If we are here the point P has not yet been found to lie inside the bounds of the cutaway plane shape, and is not yet been found to be a rim point.
            // Get the next outer edge segment, vertex A to vertex B (val to vbl in local co-ords, vag to vbg in global coords).
            // This edge segment forms a triangle with the plane origin. If P lies inside the traingle - then it will be cutaway.
            vag = vbg;
            val = vbl;
            dictNodeId =  dict_next(dictNodeId);
        }
        while (dictNodeId > 0);
    }
    
    // At this point we know if the point P is to be 'cut-away' , or shaded as a rim point.
    // If it is shaded as a rim point, we need to see if any other geometry is should occlude it.

    // Rim occlusion. 
    // If there is a 'foreign' object in front of the rim -- occlude the rim
    // We do this by firing a ray from the rim intercept point to P (i.e fire a ray to the camera).
    // If there is an object inbetween, occlude.
    // Because we can self intersect with our own mesh -as we bounce between the inner and outer surfaces
    // then we have to sometimes take many steps to reach the rim.
    // Because the 'foreign' object is co-incident with our inner our outer surface, the algorithm does not report
    // that we have hit the foriegn object -- so we run this proceedure twice.
    // The first time we fire the ray from the rim towards the camera (specifically P). The second time we
    // fire the ray from P towwards the rim. This appears to catch most hit points with foreign objects.
    // 
    if (((outer == 1) && (cutAwayShaderFac == 1) && (RimFillEnable2 != 0) && (cutawayPlaneType ==1)) && ((rimShadedFac == 1) && (RimOcclusionEnable !=0)))
    {
         // When checking to see if another object should be occluding the rim, we fire a 'ray' from the rimpoint to P on out object (this ray always = I)
        // For a complicated object (like a monkey) we may the fired ray may collide with ourselves. Fix the allowed 'self' collisions at a constant 'magic' value.
        int allowedSelfHits = 300;   
        // A small increment to move along the line between the last hitpoint and the camera.
        // Needed when we keep 'hitting' our object - e.g. if the wall of out object directly aligns with the ray from the rim through to P.
        float stepIncrement = 0.01;   
        vector startPoint = rim_interceptpoint_g;
        vector traceVector = P-rim_interceptpoint_g;  
        float searchDist = length(traceVector);

        float distToRimMargin = 0.01;
        float hitDist;
        vector hitPoint;
        float hitMeshId;
        float hitPointToRimPointDist;
        
        // drill up from the rim to P. Do we hit a 'foreign' object on the way down
        for (int i = 0; i < allowedSelfHits; ++i)     
        {
            hitDist = rayTrace2(startPoint, I , searchDist, hitPoint,hitMeshId, bVersion);
            if (  (hitDist == 0) ) break;
            hitPointToRimPointDist = length(hitPoint-P); 
            if ( hitPointToRimPointDist <= distToRimMargin) break;
            if (pointInFrontOfPlane(hitPoint, I, P)) break;
            if ((hitMeshId != objectRandNum)&& (hitPointToRimPointDist > distToRimMargin))
            {
                occlude = 1;
                break;
            }
            
            startPoint = hitPoint + I * stepIncrement;
            searchDist = length(startPoint - P);
         }

        if (occlude ==0)
        {
            // sometimes we don't hit the objects on the way up -- so lets try the way down!
            // drill down from P to the rim. Do we hit a 'foreign' object on the way down
            startPoint = P;
            traceVector = rim_interceptpoint_g-P;
            searchDist = length(traceVector);
        
            for (int i = 0; i < allowedSelfHits; ++i)     // hard code 300 tries. It appears to work. Could expose the loop count to the UI, or make the algorithm smarter if needed
            {
                hitDist = rayTrace2(startPoint, -I , searchDist, hitPoint, hitMeshId, bVersion);
                if ((hitDist == 0) ) break;
                hitPointToRimPointDist = length(hitPoint-rim_interceptpoint_g);
                if (  (hitDist == 0) || (hitPointToRimPointDist <= distToRimMargin)) break;
                if (pointInFrontOfPlane(hitPoint, -I, rim_interceptpoint_g)) break;
                if ((hitMeshId != objectRandNum) && (hitPointToRimPointDist > distToRimMargin) )
                {
                    occlude = 1;
                    break;
                }
                startPoint = hitPoint - I * stepIncrement;
                searchDist = length(startPoint - rim_interceptpoint_g);
            }
        }
        // we need to occlude the rim. No rim pixel will be drawn at P if rimShadedFac = 0
        if (occlude == 1)  rimShadedFac = 0;
    }
    
    // At this stage of the code:
    // For this point P being shaded:
    //      cutAwayShaderFac == 0 if there is no cut away effect, 
    //                       == 1 if there is a full cut away (transparent) effect
    //              
    //      rimShadedFac     == 0 if there is no rim effect at this point
    //                       == 1 if there is a rim to be shaded at this point
    //
    //      occlude          == 0 if a rim point is OK to shade
    //                       == 1 if a rim point is occluded (and shouldn't be drawn as a rim)
    //
    //      cutawayImgFac    == transparency of the cutaway (if the cutawayType = 3 = use image )  
    

    // The user may not want choose the mix between full cutaway shader and no cut away shader
    // Multiply the on/off factors by the users mixfactor 'slider' value.
    // e.g. if EffectMixFactor == 0.5, then the cut away will be 50% transparent.
    //      if the EffectMixFactor == 0, then no cut away will be seen.
    cutAwayShaderFac *= clamp(EffectMixFactor, 0.0, 1.0); 
    rimShadedFac *= clamp(EffectMixFactor, 0.0, 1.0);
    
    // If an image is being used  to define the cutaway shape/transparency, then apply this.
    if (cutawayPlaneType == 2)
    {
        cutAwayShaderFac *= cutawayImgFac;
    }
    
     // Set the rim output factor (1 = rim pixel, 0 = no rim pixel)
    // Note: the output rim factor is not attenuated by the user input RimEffectMixFactor
    RimFac = rimShadedFac;
    
    // attenuate the rim output shader mix by the amount desired by the user
    //rimFac *= RimEffectMixFactor;
    
    // set shader output factors
    float rimFac = rimShadedFac * RimEffectMixFactor;           // attenuate the rim output shader mix by the amount desired by the user
    float unCutFac = 1 -cutAwayShaderFac;
    float cutFac =  cutAwayShaderFac * (1-rimFac);
    
    // the final effect mix affects the output factors
    // the rim effect mix does not affect the output factors.
    // Set the cutaway output factor
    CutAwayFac = cutFac;

    //color rimCol = RimColor;                              // Set the rim colour to the users choice

    // Shade the rim with a diffuse shader, with the color specified by the user.
    closure color rimShader;
    if (useEmissionForRim == 1) 
    {
        if (raytype("camera")) rimShader = emission() * RimColor2;
        else  rimFac = 0;
    }
    else rimShader = diffuse(N) * RimColor2;
    
    // the Shader output is a mix between:
    //      - no change to ShaderIn                     (unCutFac)
    //      - transparent                               (cutFac)
    //      - rim shaded as diffuse or userSpecified    (rimFac)
    CutAwayShaderOut =   unCutFac   * ShaderIn       +  // uncut portion closure color holdout ( )
                         cutFac     * transparent()  +  // cutaway portion has transparency (unless this is part of the rim) 
                         rimFac     * rimShader      ;  // rim potion

}
